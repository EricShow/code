![在这里插入图片描述](https://img-blog.csdnimg.cn/20210410200442357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
package leetcode1230;

public class BHBank {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		String str = "covid2019";
		System.out.println(reformat(str));
	}
	public static String reformat(String s) {
        char[] a = s.toCharArray();
        int num1 = 0;
        int num2 = 0;
        for(char c:s.toCharArray()){
            if(c>='0'&&c<='9'){
                num1++;
            }else{
                num2++;
            }
        }
        if(Math.abs(num1-num2)>1){
            return "";
        }
        if(num1>num2){
            num1=0;
            num2=1;
        }else{
            num2=0;
            num1=1;
        }
        for(char c:s.toCharArray()){
            if(c>='0'&&c<='9'){
                a[num1] = c;
                num1 += 2;
            }
            else{
                a[num2] = c;
                num2 += 2;
            }
        }
        return new String(a);
    }

}
```

```java
return new int[] {hash.get(target-nums[i]),i};
```

```java
思路  当左右相等时，我们将两个都取或（0变1 1变0）
当左右不等时，经过水平互换，再经过01互换相当于不变

class Solution {
    public int[][] flipAndInvertImage(int[][] image) {
        int n = image.length;
        for (int i = 0; i < n; i++) {
            int left = 0, right = n - 1;
            while (left < right) {
                if (image[i][left] == image[i][right]) {
                    image[i][left] ^= 1;
                    image[i][right] ^= 1;
                }
                left++;
                right--;
            }
            if (left == right) {
                image[i][left] ^= 1;
            }
        }
        return image;
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021040609522037.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
class Solution {
    public boolean kLengthApart(int[] nums, int k) {
        //先考虑特殊情况
        if (k == 0) return true;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 1) {
                //当碰到1时判断后面的k个数有没有1
                for (int j = i + 1; j < nums.length && j <= i + k; j++) {
                    if (nums[j] == 1) return false;
                }
                //如果都为0，则i跳到i+k+1
                i += k;
            }
        }
        return true;
    }
}

```



![在这里插入图片描述](https://img-blog.csdnimg.cn/20210406101308348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
注意：测试样例可能存在超大数字，所以，一般二分查找问题都会用到long型数据，养成习惯
class Solution {
    public boolean isPerfectSquare(int num) {
        if (num < 2) {
            return true;
        }
        long left = 1; 
        long right = num/2;
        while(left<=right){
            long mid = left + (right-left)/2;
            if(mid*mid==num){
                return true;
            }
            if(mid*mid>num){
                right = mid-1;
            }
            if(mid*mid<num){
                left = mid+1;
            }
        }
        return false;
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021040621070839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        
        Stack<ListNode> stack = new Stack<>();
        if(head==null||head.next == null){
            return head;
        }
        while(head!=null){
            stack.push(head);
            head = head.next;
        }
        ListNode node = stack.pop();
        ListNode dummy = node;
        //栈中的结点全部出栈，然后重新连成一个新的链表
        while (!stack.isEmpty()) {
            ListNode tempNode = stack.pop();
            node.next = tempNode;
            node = node.next;
        }
        //最后一个结点就是反转前的头结点，一定要让他的next
        //等于空，否则会构成环
        node.next = null;

        
        return dummy;
    }
}
```



![在这里插入图片描述](https://img-blog.csdnimg.cn/20210406212055243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210406212414777.png)

```java
思路：1、找到第一个前边小于后边的数字a[i]
	  2、从后向前找第一个大于a[i]的数字，并交换顺序
	  3、将i+1到n（左闭右开）反转
class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        if (i >= 0) {
            int j = nums.length - 1;
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    public void reverse(int[] nums, int start) {
        int left = start, right = nums.length - 1;
        while (left < right) {
            swap(nums, left, right);
            left++;
            right--;
        }
    }
}

```


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210406222428180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
力扣48删除最长不含重复字符的子串
细节：i只有在添加元素的时候才增长，否则不用增长
import java.util.*;
public class Solution {
    /**
     * 
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int maxLength (int[] arr) {
        // write code here
        Set<Integer> set = new HashSet<>();
        int max = 0;
        int j = 0;
        for(int i=0; i<arr.length; ){
            if(set.contains(arr[i])){
                while(set.contains(arr[i])){
                    set.remove(arr[j]);
                    j++;
                }
            }else{
                set.add(arr[i]);
                i++;
            }
            max = Math.max(i-j,max);
        }
        return max;
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401225906758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
class Solution {
    public boolean isMonotonic(int[] A) {
        int len = A.length;
        int countIncrease = 0, countDecrease = 0;
        for (int i = 0; i < len - 1; i++) {
            if (A[i] <= A[i + 1])
                countIncrease++;
            if (A[i] >= A[i + 1])
                countDecrease++;
        }
        return countIncrease == len - 1 || countDecrease == len - 1;
    }
}
```




在这里插入图片描述

```java
思路1：找出链表长度，遍历两次
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthToLast(ListNode head, int k) {
        int len = length(head);
        for(int i=0; i<len; i++){
            if(i == len-k){
                return head.val;
            }
            head = head.next;
        }
        return 0;
    }
    public int length(ListNode head){
        int len = 0;
        while(head!=null){
            len++;
            head = head.next;
        }
        return len;
    }
}
```

```java
思路2：利用双指针，控制两个指针之间的距离为k,当快指针结束的时候，慢指针即为所求

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthToLast(ListNode head, int k) {
        ListNode dummyHead = new ListNode(-1);
        dummyHead.next = head;
        ListNode p = dummyHead;
        ListNode q = dummyHead;
        for (int i = 0; i < k; i++) {
            q = q.next;
        }
        while (q!=null) {
            q = q.next;
            p = p.next;
        }
        return p.val;
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210312152816885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
//思路深度优先搜索，只要当前点满足条件，就往下一步出发

class Solution {

    public int movingCount(int m, int n, int k) {
        boolean[][] visited = new boolean[m][n];
        return dfs(visited, m, n, k, 0, 0);
    }

    private int dfs(boolean[][] visited, int m, int n, int k, int i, int j) {
        if(i >= m || j >= n || visited[i][j] || bitSum(i) + bitSum(j) > k) return 0;
        visited[i][j] = true;
        return 1 + dfs(visited, m, n, k, i + 1, j) + dfs(visited, m, n, k, i, j + 1) ;
    }

    private int bitSum(int n) {
        int sum = 0;
        while(n > 0) {
            sum += n % 10;
            n /= 10; 
        }
        return sum;
    }
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210312160702230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210312160645630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Node cur = head;
        Map<Node, Node> map = new HashMap<>();
        // 3. 复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
        while(cur != null) {
            map.put(cur, new Node(cur.val));
            cur = cur.next;
        }
        cur = head;  重新遍历一遍head
        // 4. 构建新链表的 next 和 random 指向
        操作：get(cur).next表示的是keyvalue的next，而get(cur.next)指的是cur.next对应的键值，也就是复制的cur.next
        while(cur != null) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        // 5. 返回新链表的头节点
        return map.get(head);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210312165817246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
进栈时考虑  如果不是最小值，就入栈一个最小栈的栈顶元素

class MinStack {
    private Stack<Integer> s1;
    private Stack<Integer> s2;
    /** initialize your data structure here. */
    public MinStack() {
        s1=new Stack<>();
        s2=new Stack<>();
    }
    
    public void push(int x) {
        s1.add(x);
        if(s2.empty()||s2.peek()>x)
            s2.add(x);
        else
            s2.add(s2.peek());
    }
    
    public void pop() {
        s1.pop();
        s2.pop();
    }
    
    public int top() {
        return s1.peek();
    }
    
    public int min() {
        return s2.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */

```

```java
入栈时，判断是不是最小值
如果是，最小栈入栈
出栈时，判断出栈的是不是最小值
如果是，最小栈出栈
二者的相似之处，维护最小栈栈顶元素为最小值
class MinStack {
    Stack<Integer> stack1;
    Stack<Integer> stack2;
    /** initialize your data structure here. */
    public MinStack() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
        stack2.push(Integer.MAX_VALUE);

    }
    
    public void push(int x) {
        stack1.push(x);
        if(stack2.peek()>=x){
            stack2.push(x);
        }
        
    }
    
    public void pop() {
        int min =stack2.peek();
        if(stack1.peek() == min){
            stack2.pop();
        }
        stack1.pop();
    }
    
    public int top() {
        return stack1.peek();
    }
    
    public int min() {
        return stack2.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401225906758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
class Solution {
    public boolean isMonotonic(int[] A) {
        int len = A.length;
        int countIncrease = 0, countDecrease = 0;
        for (int i = 0; i < len - 1; i++) {
            if (A[i] <= A[i + 1])
                countIncrease++;
            if (A[i] >= A[i + 1])
                countDecrease++;
        }
        return countIncrease == len - 1 || countDecrease == len - 1;
    }
}
```




在这里插入图片描述

```java
思路1：找出链表长度，遍历两次
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthToLast(ListNode head, int k) {
        int len = length(head);
        for(int i=0; i<len; i++){
            if(i == len-k){
                return head.val;
            }
            head = head.next;
        }
        return 0;
    }
    public int length(ListNode head){
        int len = 0;
        while(head!=null){
            len++;
            head = head.next;
        }
        return len;
    }
}
```

```java
思路2：利用双指针，控制两个指针之间的距离为k,当快指针结束的时候，慢指针即为所求

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthToLast(ListNode head, int k) {
        ListNode dummyHead = new ListNode(-1);
        dummyHead.next = head;
        ListNode p = dummyHead;
        ListNode q = dummyHead;
        for (int i = 0; i < k; i++) {
            q = q.next;
        }
        while (q!=null) {
            q = q.next;
            p = p.next;
        }
        return p.val;
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210312152816885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
//思路深度优先搜索，只要当前点满足条件，就往下一步出发

class Solution {

    public int movingCount(int m, int n, int k) {
        boolean[][] visited = new boolean[m][n];
        return dfs(visited, m, n, k, 0, 0);
    }

    private int dfs(boolean[][] visited, int m, int n, int k, int i, int j) {
        if(i >= m || j >= n || visited[i][j] || bitSum(i) + bitSum(j) > k) return 0;
        visited[i][j] = true;
        return 1 + dfs(visited, m, n, k, i + 1, j) + dfs(visited, m, n, k, i, j + 1) ;
    }

    private int bitSum(int n) {
        int sum = 0;
        while(n > 0) {
            sum += n % 10;
            n /= 10; 
        }
        return sum;
    }
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210312160702230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210312160645630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Node cur = head;
        Map<Node, Node> map = new HashMap<>();
        // 3. 复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
        while(cur != null) {
            map.put(cur, new Node(cur.val));
            cur = cur.next;
        }
        cur = head;  重新遍历一遍head
        // 4. 构建新链表的 next 和 random 指向
        操作：get(cur).next表示的是keyvalue的next，而get(cur.next)指的是cur.next对应的键值，也就是复制的cur.next
        while(cur != null) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        // 5. 返回新链表的头节点
        return map.get(head);
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210312165817246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
进栈时考虑  如果不是最小值，就入栈一个最小栈的栈顶元素

class MinStack {
    private Stack<Integer> s1;
    private Stack<Integer> s2;
    /** initialize your data structure here. */
    public MinStack() {
        s1=new Stack<>();
        s2=new Stack<>();
    }
    
    public void push(int x) {
        s1.add(x);
        if(s2.empty()||s2.peek()>x)
            s2.add(x);
        else
            s2.add(s2.peek());
    }
    
    public void pop() {
        s1.pop();
        s2.pop();
    }
    
    public int top() {
        return s1.peek();
    }
    
    public int min() {
        return s2.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */

```

```java
入栈时，判断是不是最小值
如果是，最小栈入栈
出栈时，判断出栈的是不是最小值
如果是，最小栈出栈
二者的相似之处，维护最小栈栈顶元素为最小值
class MinStack {
    Stack<Integer> stack1;
    Stack<Integer> stack2;
    /** initialize your data structure here. */
    public MinStack() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
        stack2.push(Integer.MAX_VALUE);

    }
    
    public void push(int x) {
        stack1.push(x);
        if(stack2.peek()>=x){
            stack2.push(x);
        }
        
    }
    
    public void pop() {
        int min =stack2.peek();
        if(stack1.peek() == min){
            stack2.pop();
        }
        stack1.pop();
    }
    
    public int top() {
        return stack1.peek();
    }
    
    public int min() {
        return stack2.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
```

陌陌面试算法频率
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315090458192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315084919327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315085004102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
```java
递归：
return 1 / (x * myPow(x, - n - 1));含义：return 1/(myPow(x,-n)) 或者 return myPow(1/x,-n)会出现错误
错误原因未知

class Solution {
    public double myPow(double x, int n) {
        if(n == 0){
            return 1;
        }else if(n < 0){
            return 1 / (x * myPow(x, - n - 1));
        }else if(n % 2 == 1){
            return x * myPow(x, n - 1);
        }else{
            return myPow(x * x, n / 2);
        }     
    }
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315091127221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
注意指针变换条件
当height[l]<height[r]时，只能移动较小的，因为移动较大的一个只会导致area越来越小，因为area由小的决定，r-l减小。只能希望高度增加。所以通过移动小的来增加高度，才可能得到的较大的面积
```java
class Solution {
    public int maxArea(int[] height) {
        int l=0, r=height.length-1;
        int ans = 0;
        while(l<r){
            int area = Math.min(height[l],height[r])*(r-l);
            ans = Math.max(area,ans);
            if(height[l]<height[r]) l++;
            else r--;
        }
        return ans;
    }
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315092640422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
思路：HashMap用来存储数值和索引，因为他只有两个值，所以不需要回溯算法
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> hash = new HashMap<>();
        for(int i=0; i<nums.length; i++){
            if(hash.containsKey(target-nums[i])){
                return new int[] {hash.get(target-nums[i]),i};
            }
            hash.put(nums[i],i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315102440607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
class Solution {
    public int strToInt(String str) {
        char[] ch = str.trim().toCharArray();
        int len = ch.length;
        if(len==0||str.length()==0||str==null){
            return 0;
        }
        int i=0;
        int sign = 1;
        int ret = 0;
        if(ch[0]=='-'){
            sign = -1;
            i = 1;
        }
        int bdny = Integer.MAX_VALUE/10;
        if(ch[0]=='+'){
            i = 1;
        }
        for(int j=i; j<len; j++){
            if(ch[j]<'0'||ch[j]>'9'){
                break;
            }
            if(ret>bdny||(ret==bdny&&ch[j]>'7')){
                return sign>0?Integer.MAX_VALUE:Integer.MIN_VALUE;
            }
            ret = ret*10+ch[j]-'0';
            
        }
        return sign*ret;
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315160743893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
完整代码刻在eclipse运行
package leetcode1230;
import java.util.*;

public class singleNumber {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] arr1 = {1,1,1,2,2,5,5,5,2,100};
		System.out.println(f(arr1));
		
	}
	public static int f(int[] nums) {
        Map<Integer,Integer> hash = new HashMap<>();
        for(int i=0; i<nums.length; i++){
        	if(hash.containsKey(nums[i])){
        		hash.put(nums[i],hash.get(nums[i])+1);
        	}
        	else{
        		hash.put(nums[i], 1);
        	}
        }
        for(int i=0; i<nums.length; i++){
            if(hash.get(nums[i])==1){
                return nums[i];
            }
        }
        return -1;
        
    }
}

```


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315164431181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
package leetcode1230;
import java.util.*;

public class twoSum {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] nums = {2,7,11,15};
		int target = 9;
		int[] ret = f(nums,target);
		for(int i=0; i<ret.length; i++){
			System.out.println(ret[i]);
		}
	}
	public static int[] f(int[] nums, int target) {
        Map<Integer,Integer> hash = new HashMap<>();
        for(int i=0; i<nums.length; i++){
            if(hash.containsKey(nums[i])){
                hash.put(nums[i],hash.get(nums[i])+1);
            }
            else{
                hash.put(nums[i],1);
            }
        }
        for(int i=0; i<nums.length; i++){
            if(hash.containsKey(target-nums[i])){
                if(nums[i]==(target-nums[i])){
                    if(hash.get(nums[i])>1){
                        return new int[] {nums[i],target-nums[i]};
                    }
                    else{
                        return null;
                    }
                }
                return new int[] {nums[i],target-nums[i]};
            }
        }
        return null;
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315230842366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
 第一段代码是错的，还未找到错误原因
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> que = new LinkedList<>();
        List<List<Integer>> ret = new ArrayList<>();
        if(root != null) que.add(root);
        else return ret;
        int level = 0;
        
        while(!que.isEmpty()){
            int size = que.size();
            LinkedList<Integer> ls  = new LinkedList<>();
            for(int i=0; i<size; i++){
                TreeNode ans = que.poll();
                if(level % 2 == 1) ls.addLast(ans.val); // 偶数层 -> 队列头部
                else ls.addFirst(ans.val);
                if(ans.left!=null){
                    que.add(ans.right);
                }
                if(ans.right!=null){
                    que.add(ans.left);
                }
                
            }
            level++;
            ret.add(ls);
        }
        return ret;
    }
}
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        if(root != null) queue.add(root);
        while(!queue.isEmpty()) {
            LinkedList<Integer> tmp = new LinkedList<>();
            for(int i = queue.size(); i > 0; i--) {
                TreeNode node = queue.poll();
                if(res.size() % 2 == 0) tmp.addLast(node.val); // 偶数层 -> 队列头部
                else tmp.addFirst(node.val); // 奇数层 -> 队列尾部
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            }
            res.add(tmp);
        }
        return res;
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315160743893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
完整代码刻在eclipse运行
package leetcode1230;
import java.util.*;

public class singleNumber {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] arr1 = {1,1,1,2,2,5,5,5,2,100};
		System.out.println(f(arr1));
		
	}
	public static int f(int[] nums) {
        Map<Integer,Integer> hash = new HashMap<>();
        for(int i=0; i<nums.length; i++){
        	if(hash.containsKey(nums[i])){
        		hash.put(nums[i],hash.get(nums[i])+1);
        	}
        	else{
        		hash.put(nums[i], 1);
        	}
        }
        for(int i=0; i<nums.length; i++){
            if(hash.get(nums[i])==1){
                return nums[i];
            }
        }
        return -1;
        
    }
}

```


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315164431181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
package leetcode1230;
import java.util.*;

public class twoSum {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] nums = {2,7,11,15};
		int target = 9;
		int[] ret = f(nums,target);
		for(int i=0; i<ret.length; i++){
			System.out.println(ret[i]);
		}
	}
	public static int[] f(int[] nums, int target) {
        Map<Integer,Integer> hash = new HashMap<>();
        for(int i=0; i<nums.length; i++){
            if(hash.containsKey(nums[i])){
                hash.put(nums[i],hash.get(nums[i])+1);
            }
            else{
                hash.put(nums[i],1);
            }
        }
        for(int i=0; i<nums.length; i++){
            if(hash.containsKey(target-nums[i])){
                if(nums[i]==(target-nums[i])){
                    if(hash.get(nums[i])>1){
                        return new int[] {nums[i],target-nums[i]};
                    }
                    else{
                        return null;
                    }
                }
                return new int[] {nums[i],target-nums[i]};
            }
        }
        return null;
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315230842366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
 第一段代码是错的，还未找到错误原因
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> que = new LinkedList<>();
        List<List<Integer>> ret = new ArrayList<>();
        if(root != null) que.add(root);
        else return ret;
        int level = 0;
        
        while(!que.isEmpty()){
            int size = que.size();
            LinkedList<Integer> ls  = new LinkedList<>();
            for(int i=0; i<size; i++){
                TreeNode ans = que.poll();
                if(level % 2 == 1) ls.addLast(ans.val); // 偶数层 -> 队列头部
                else ls.addFirst(ans.val);
                if(ans.left!=null){
                    que.add(ans.right);
                }
                if(ans.right!=null){
                    que.add(ans.left);
                }
                
            }
            level++;
            ret.add(ls);
        }
        return ret;
    }
}
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        if(root != null) queue.add(root);
        while(!queue.isEmpty()) {
            LinkedList<Integer> tmp = new LinkedList<>();
            for(int i = queue.size(); i > 0; i--) {
                TreeNode node = queue.poll();
                if(res.size() % 2 == 0) tmp.addLast(node.val); // 偶数层 -> 队列头部
                else tmp.addFirst(node.val); // 奇数层 -> 队列尾部
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            }
            res.add(tmp);
        }
        return res;
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210308221140562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root==p || root==q){
            return root;
        }
        //如果left为空，那么说明p和q都不在左子树，所以直接返回右节点
        //同理
        //如果left和right都为空，说明p和q在两侧，所以返回root
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if(left==null) return right;
        if(right==null) return left;
        return root;
    }
}
```


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210308223342410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ret = new ArrayList<>();
        List<Integer> ls = new ArrayList<>();
        int len = nums.length;
        backtrack(0,nums,ls,ret);
        return ret;
    }
    public void backtrack(int start, int[] nums, List<Integer> ls,List<List<Integer>> ret){
        ret.add(new ArrayList<>(ls));
        for(int i=start; i<nums.length; i++){
            ls.add(nums[i]);
            backtrack(i+1,nums,ls,ret);
            ls.remove(ls.size()-1);
        }
    }
}
```


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210308232720260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int len = flowerbed.length;
        if(n==0){
            return true;
        }
        for(int i=0; i<flowerbed.length; i++){
            if(flowerbed[i]==0&&(i==0||flowerbed[i-1]==0)&&(i==len-1||flowerbed[i+1]==0)){
                flowerbed[i]=1;
                n--;
                if(n<=0){
                    return true;
                }
            }
        }
        return false;
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315160743893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
完整代码刻在eclipse运行
package leetcode1230;
import java.util.*;

public class singleNumber {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] arr1 = {1,1,1,2,2,5,5,5,2,100};
		System.out.println(f(arr1));
		
	}
	public static int f(int[] nums) {
        Map<Integer,Integer> hash = new HashMap<>();
        for(int i=0; i<nums.length; i++){
        	if(hash.containsKey(nums[i])){
        		hash.put(nums[i],hash.get(nums[i])+1);
        	}
        	else{
        		hash.put(nums[i], 1);
        	}
        }
        for(int i=0; i<nums.length; i++){
            if(hash.get(nums[i])==1){
                return nums[i];
            }
        }
        return -1;
        
    }
}

```


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315164431181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
package leetcode1230;
import java.util.*;

public class twoSum {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] nums = {2,7,11,15};
		int target = 9;
		int[] ret = f(nums,target);
		for(int i=0; i<ret.length; i++){
			System.out.println(ret[i]);
		}
	}
	public static int[] f(int[] nums, int target) {
        Map<Integer,Integer> hash = new HashMap<>();
        for(int i=0; i<nums.length; i++){
            if(hash.containsKey(nums[i])){
                hash.put(nums[i],hash.get(nums[i])+1);
            }
            else{
                hash.put(nums[i],1);
            }
        }
        for(int i=0; i<nums.length; i++){
            if(hash.containsKey(target-nums[i])){
                if(nums[i]==(target-nums[i])){
                    if(hash.get(nums[i])>1){
                        return new int[] {nums[i],target-nums[i]};
                    }
                    else{
                        return null;
                    }
                }
                return new int[] {nums[i],target-nums[i]};
            }
        }
        return null;
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315230842366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
 第一段代码是错的，还未找到错误原因
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> que = new LinkedList<>();
        List<List<Integer>> ret = new ArrayList<>();
        if(root != null) que.add(root);
        else return ret;
        int level = 0;
        
        while(!que.isEmpty()){
            int size = que.size();
            LinkedList<Integer> ls  = new LinkedList<>();
            for(int i=0; i<size; i++){
                TreeNode ans = que.poll();
                if(level % 2 == 1) ls.addLast(ans.val); // 偶数层 -> 队列头部
                else ls.addFirst(ans.val);
                if(ans.left!=null){
                    que.add(ans.right);
                }
                if(ans.right!=null){
                    que.add(ans.left);
                }
                
            }
            level++;
            ret.add(ls);
        }
        return ret;
    }
}
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        if(root != null) queue.add(root);
        while(!queue.isEmpty()) {
            LinkedList<Integer> tmp = new LinkedList<>();
            for(int i = queue.size(); i > 0; i--) {
                TreeNode node = queue.poll();
                if(res.size() % 2 == 0) tmp.addLast(node.val); // 偶数层 -> 队列头部
                else tmp.addFirst(node.val); // 奇数层 -> 队列尾部
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            }
            res.add(tmp);
        }
        return res;
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210227153124935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210227153130697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
class Solution {
    public double quickMul(double x, long N) {
        if (N == 0) {
            return 1.0;
        }
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }

    public double myPow(double x, int n) {
        long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
}
```

注释：
	暴力解法需要重复运算N-1次
	可以根据中间结果取平方的方式进行运算
	每次保存上一个结果的平方或平方*x
	取决于N取余时是否整除
	整除取平方  不整除取平方*x

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210227155037127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021022715522896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210227155238345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210227155244214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length == 0) {
            return 0;
        }

        int n = prices.length;
        // f[i][0]: 手上持有股票的最大收益
        // f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益
        // f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益
        int[][] f = new int[n][3];
        f[0][0] = -prices[0];//第一天持有股票  需要减去第一天的价格
        f[0][1] = 0; //第一天不持有股票，
        f[0][2] = 0; //第一天不持有股票，这两行没有也要被定义数组时初始化为0
        for (int i = 1; i < n; ++i) {
            f[i][0] = Math.max(f[i - 1][0], f[i - 1][2] - prices[i]);
            f[i][1] = f[i - 1][0] + prices[i];
            f[i][2] = Math.max(f[i - 1][1], f[i - 1][2]);
        }

        return Math.max(f[n - 1][1], f[n - 1][2]);
    }
}

```



![在这里插入图片描述](https://img-blog.csdnimg.cn/2021022716104334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210227161225323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210227161240124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210227161250874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
public class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = amount + 1;
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, max);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}![在这里插入图片描述](https://img-blog.csdnimg.cn/2021012813202067.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

​```java
思路：
	判断是不是叶子节点
	右节点中也有左叶子节点
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        return root != null ? dfs(root) : 0;
    }

    public int dfs(TreeNode node) {
        int ans = 0;
        if (node.left != null) {
            ans += isLeafNode(node.left) ? node.left.val : dfs(node.left);
        }
        if (node.right != null && !isLeafNode(node.right)) {
            ans += dfs(node.right);
        }
        return ans;
    }

    public boolean isLeafNode(TreeNode node) {
        return node.left == null && node.right == null;
    }
}
​```

​```java
class Solution {
    
    public int sumOfLeftLeaves(TreeNode root) {
        if(root==null) return 0;
        return sumOfLeftLeaves(root.left) 
            + sumOfLeftLeaves(root.right) 
            + (root.left!=null && root.left.left==null && root.left.right==null ? root.left.val : 0);
    }
}
​```

```

## 力扣566重塑数组
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210217103014600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210217103020734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210217103024273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210305231220118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
思路：
1、规定4个方向数组  决定下一次的前进方向  
2、建立访问数组，标记每个数组是否访问过

注意改变前进方向的条件（下一个数组行超限 || 列超限（>=len || <0） || 下一个位置遍历过）

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if(matrix.length==0||matrix[0].length==0){
            return new int[0];
        }
        int row = matrix.length;
        int col = matrix[0].length;
        int total = row*col;
        int[] ans = new int[total];
        int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        boolean[][] been = new boolean[row][col];
        int directionindex = 0;
        int row0 = 0;
        int col0 = 0;
        for(int i=0; i<total; i++){
            ans[i] = matrix[row0][col0];
            been[row0][col0] = true;
            int next0 = row0+dir[directionindex][0];
            int next1 = col0+dir[directionindex][1];
            if(next0<0||next0>=row||next1>=col||next1<0||been[next0][next1]==true){
                directionindex++;
                if(directionindex==4) directionindex=0;
            }
            row0 = row0 + dir[directionindex][0];
            col0 = col0 + dir[directionindex][1];

        }
        return ans;
    }
}
```

复习对称二叉树
镜像二叉树

力扣 根据前序遍历和中序遍历确定二叉树
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210304084422516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/202103040845552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
基本思路
前序遍历确定根节点是哪个（第一个就是根节点）
中序遍历根据已知根节点确定左右子树的元素组成
根节点左  左子树  
根节点右  右子树
再根据前序遍历确定  左子树的根节点 
根据左子树的根节点确定   左子树元素的左右子树

```java
理解：每次更新的是提供的前序遍历序列和中序遍历序列 ，官方答案提供的是更新索引，不更新前、中序遍历
class Solution {
	public TreeNode buildTree(int[] preorder, int[] inorder) {
		if(preorder.length==0 || inorder.length==0) {
			return null;
		}
		//根据前序数组的第一个元素，就可以确定根节点
		TreeNode root = new TreeNode(preorder[0]);
		for(int i=0;i<preorder.length;++i) {
			//用preorder[0]去中序数组中查找对应的元素
			if(preorder[0]==inorder[i]) {
				//将前序数组分成左右两半，再将中序数组分成左右两半
				//之后递归的处理前序数组的左边部分和中序数组的左边部分
				//递归处理前序数组右边部分和中序数组右边部分
				int[] pre_left = Arrays.copyOfRange(preorder,1,i+1);
				int[] pre_right = Arrays.copyOfRange(preorder,i+1,preorder.length);
				int[] in_left = Arrays.copyOfRange(inorder,0,i);
				int[] in_right = Arrays.copyOfRange(inorder,i+1,inorder.length);
				root.left = buildTree(pre_left,in_left);
				root.right = buildTree(pre_right,in_right);
				break;
			}
		}
		return root;
	}
}


```
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021030410342839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1]; // 默认初始化值都为0
        for (int i = 1; i <= n; i++) {
            dp[i] = i; // 最坏的情况就是每次+1
            for (int j = 1; i - j * j >= 0; j++) { 
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 动态转移 
                //dp[0]=0，当i-j*j=0时，说明只需要一次就可以，如果i-j*j！=0时，说明我们需要根据前面的最优结果进行+1
                //例如5  因为4的最优只有1个即可，因此5只需在4的基础上+1
            }
        }
        return dp[n];
    }
}

```
快速排序思想
1、第一轮   最左侧元素作为Key值（目标：>Key 右侧，<Key 左侧）
	双指针放在第二个元素和最后一个元素
		（1）从r指针开始，寻找小于Key的元素，找到时停下
		（2）从l指针开始，寻找大于Key的元素，找到时停下，交换l、r指针元素的位置
		（3）重复（1）直到左右指针重合（l=r）
		（4）重合后将l指针元素与Key交换顺序（实现了左<Key右>Key）
2、将Key左侧的作为新的待排列的数组，重复1操作
      将Key右侧的作为新的待排列的数组，重复1操作
3、排列完成标志  l>r或者输入数组为空时说明排列完成

```java
class Solution {
    public void sortColors(int[] nums) {
        int len = nums.length;
        quicksort(nums,0,len-1);
    }

    public int[] quicksort(int[] nums,int start,int end){
        if(start>end){
            return nums;
        }
        int Key = nums[start];
        int left = start;
        int right = end;
        while(left<right){
            while(left<right&&nums[right]>=Key){  //从右向左找到<Key的值终止循环
                right--;
            }
            while(left<right&&nums[left]<=Key){ //从左向右找到>Key的值终止循环
                left++;
            }
            if(left<right){
                swap(nums,left,right);
            }
            if(left>=right){
                swap(nums,start,left);
            }
        }
        quicksort(nums,left+1,end);
        quicksort(nums,start,left-1);
        return nums;

    }
    public void swap(int[] nums, int a, int b){
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }
}
```

归并排序 核心思想（两两有序合并）
1、将序列中待排序数字分为若干组，每个数字分为一组
2、将若干个组凉凉合并，保证合并后的数组是有序的
3、重复第二部操直到只剩下一组

两两合并原则：，比较两组数据头部大小，将小的放入新的序列，更新头部指针，重复操作

## 剑指offer57 和为S的连续正数序列
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210127154438356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021012716105393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
思路
class Solution {
    public int[][] findContinuousSequence(int target) {
        List<int[]> result = new ArrayList<int[]>();
        int sum = 0;
        for(int l=1,r=2;l<r;){
            sum = (l+r)*(r-l+1)/2;
            if(sum==target){
                int[] res = new int[r-l+1];
                for(int i=l; i<=r; i++){
                    res[i-l] = i;
                }
                result.add(res);
                l++;
            }
            else if(sum>target){
                l++;
            }
            else{
                r++;
            }
        }
        int len = result.size();
        int[][] a = new int[len][];
        result.toArray(a);
        return a; 
    }
}
```


## 力扣1013 将数组分成和相等的三个部分
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210127164941426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
class Solution {
    public boolean canThreePartsEqualSum(int[] A) {
        int sum = 0;
        for(int i : A){
            sum += i;
        }
        if(sum%3 != 0){
            // 总和不是3的倍数，直接返回false
            return false;
        }

        // 使用双指针,从数组两头开始一起找，节约时间
        int left = 0;
        int leftSum = A[left];
        int right = A.length - 1;
        int rightSum = A[right];

        // 使用left + 1 < right 的原因，防止只能将数组分成两个部分
        // 例如：[1,-1,1,-1]，使用left < right作为判断条件就会出错
        while(left + 1 < right){
            if(leftSum == sum/3 && rightSum == sum/3){
                // 左右两边都等于 sum/3 ，中间也一定等于
                return true;
            }
            if(leftSum != sum/3){
                // left = 0赋予了初值，应该先left++，在leftSum += A[left];
                leftSum += A[++left];
            }
            if(rightSum != sum/3){
                // right = A.length - 1 赋予了初值，应该先right--，在rightSum += A[right];
                rightSum += A[--right];
            }
        }
        return false;  
    }
}
```


## 力扣112 路径总和
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210127191436920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
/**
思路：当节点为空时，那么说明这条路没有
	当节点没有子节点是，返回这个节点是不是和输入的目标差相同，相同则说明找到了满足条件的路径
	当节点不为空时，将当前节点移动到它的左右子节点进行判断，同时输入的目标也应该减去当前节点的val
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null){
            return false;
        }
        if(root.left == null && root.right == null){
            return root.val == sum;
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
        
    }
}


```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210122224942528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210122225042234.png)


```java
思路  用List从低位到高位依次存储，然后Collections.reverse(res);逆置列表
class Solution {
    public List<Integer> addToArrayForm(int[] A, int K) {
        List<Integer> res = new ArrayList<Integer>();
        int n = A.length;
        for (int i = n - 1; i >= 0; --i) {
            int sum = A[i] + K % 10;
            K /= 10;
            if (sum >= 10) {
                K++;
                sum -= 10;
            }
            res.add(sum);
        }
        for (; K > 0; K /= 10) {
            res.add(K % 10);
        }
        Collections.reverse(res);
        return res;
    }
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210122225047244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
class Solution {
    public List<Integer> addToArrayForm(int[] A, int K) {
        List<Integer> res = new ArrayList<Integer>();
        int n = A.length;
        for (int i = n - 1; i >= 0 || K > 0; --i, K /= 10) {
            if (i >= 0) {
                K += A[i];
            }
            res.add(K % 10);
        }
        Collections.reverse(res);
        return res;
    }
}


```

## 力扣965 单值二叉树
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121194127548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```csharp
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int a = 0;
    int val = 0;
    public boolean isUnivalTree(TreeNode root) {
        if(a == 0){
            val = root.val;
        }
        a++;
        if(root == null){
            return true;
        }
        if(root.val != val){
            return false;
        }
        return isUnivalTree(root.left)&&isUnivalTree(root.right);
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121194341508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```csharp
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isUnivalTree(TreeNode root) {
        boolean flag = true;
        if(root == null) {
            return true;
        }
        flag = isUnivalTree(root.left);
        flag &=isUnivalTree(root.right);

        if((root.left!=null && root.left.val!=root.val) || (root.right!=null && root.right.val!=root.val)) {
            flag = false;
        }
        return flag;
    }
}

```


## 力扣617 合并二叉树
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121201204114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```csharp
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if(t1 == null){
            return t2;
        }
        if(t2 == null){
            return t1;
        }
        TreeNode merge = new TreeNode(t1.val + t2.val);
        merge.left = mergeTrees(t1.left, t2.left);
        merge.right = mergeTrees(t1.right, t2.right);
        return merge;
    }
}
```

## 力扣167 两数之和2

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121215501670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121215412564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```csharp
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int len = numbers.length;
        int k2 = len-1;
        int k1 = 0;
        int[] result = new int[2];
        while(k1<k2){
            if(numbers[k1]+numbers[k2]==target){
                result[0] = k1+1;
                result[1] = k2+1;
                return result;
            }
            if(numbers[k1]+numbers[k2]>target){
                k2--;
            }
            else{
                k1++;
            }
        }
        return result;
    }
}
```
## 剑指offer11 旋转数组的最小数字
![s](https://img-blog.csdnimg.cn/20210121221723457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```csharp
class Solution {
    public int minArray(int[] numbers) {
        int result = numbers[0];
        for(int i=1; i<numbers.length; i++){
            if(numbers[i]<numbers[i-1]){
                return numbers[i];
            }
        }
        return result;
    }
}
```
## 剑指offer09 用两个栈实现队列
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121224605700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)



```java
思路：用两个栈   栈1用来增加元素，stack1.push即可
栈2用来删除元素，首先，当栈2不为空时，直接pop()
当栈2为空时，将刚刚增加的元素（栈1中的元素依次入栈，可能是多个，可以理解为栈1是栈2的仓库，没有了就来拿），当栈2仍然为空时（栈1也是空的，栈2也是空的），返回-1。
class CQueue {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    public CQueue() {

    }
    
    public void appendTail(int value) {
        stack1.push(value);
    }
    
    public int deleteHead() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }

        }
        if(stack2.isEmpty()){
            return -1;
        }
        else{
            int head = stack2.pop();
            return head;
        }
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```

## 剑指offer18 删除链表中的节点

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2:

输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        if(head==null){
            return head;
        }
        ListNode a = new ListNode(0);
        ListNode b = a;
        while(head!=null){
            if(head.val != val){
                ListNode ans = new ListNode(head.val);
                a.next = ans;
                a = a.next;
            }
            head = head.next;
        }
        return b.next;
    }
}
```


## 面试题0..06 回文链表

编写一个函数，检查输入的链表是否是回文的。

示例 1：

输入： 1->2
输出： false 
示例 2：

输入： 1->2->2->1
输出： true 

```java
思路：将原链表的值全部送入栈中（倒置链表值）
将链表中的值与栈中的值依次送出，比较是否相同（比较len/2次即可）
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        Stack<Integer> stack = new Stack<Integer>();
        ListNode a = new ListNode(0,head);
        a = a.next;
        int num = 0;
        while(a!=null){
            stack.push(a.val);
            a = a.next;
            num++;
        }
        for(int i = 0;i<num/2;i++){
            int ans1 = stack.pop();
            int ans2 = head.val;
            head = head.next;
            if(ans1 != ans2){
                return false;
            }
        }
        return true;
    }
}
```
## 力扣1290 二进制链表转整数
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210120211236489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
class Solution {
    public int getDecimalValue(ListNode head) {
        int len = getLength(head);
        int sum = 0;
        for(int i=0;i<len;i++){
            sum += head.val * Math.pow(2,len-1-i);
            head = head.next;
        }
        return sum;
    }
    public int getLength(ListNode head){
        int len = 0;
        while(head!=null){
            head = head.next;
            len++;
        }
        return len;
    }
}
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val; 
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int getDecimalValue(ListNode head) {
        int sum = 0;
        while (head != null) {
            sum = (sum << 1) + head.val;
            head = head.next;
        }
        return sum;
    }
}

```
## 剑指offer25合并两个排序的链表
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210120213016755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        int len1 = getLength(l1);
        int len2 = getLength(l2);
        if(len1 == 0){
            return l2;
        }
        if(len2 == 0){
            return l1;
        }
        int[] arr = new int[len1+len2];
        for(int i=0; i<len1; i++){
            arr[i] = l1.val;
            l1 = l1.next;
        }
        for(int i=len1; i<len1+len2; i++){
            arr[i] = l2.val;
            l2 = l2.next;
        }
        Arrays.sort(arr);
        ListNode head = new ListNode(arr[0]);
        ListNode cur = head;
        for(int i=1; i<len1+len2; i++){
            ListNode ans = new ListNode(arr[i]);
            head.next = ans;
            head = head.next;            
        }
        return cur;
    }
    public int getLength(ListNode head){
        int len = 0;
        while(head!=null){
            len++;
            head = head.next;
        }
        return len;
    }
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210120213145372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dum = new ListNode(0), cur = dum;
        while(l1 != null && l2 != null) {
            if(l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
            }
            else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        cur.next = l1 != null ? l1 : l2;
        return dum.next;
    }
}
```
## 力扣328 奇偶链表
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210120214252873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
有问题   需要开辟新空间的方法，
即链表的空间复杂度为O(N)
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode oddEvenList(ListNode head) {
        ListNode a = new ListNode(0);
        ListNode cur1 = a;
        ListNode b = new ListNode(0);
        ListNode cur2 = b;
        int i = 1;
        while(head!=null){
            if(i%2==1){
                ListNode ans1 = new ListNode(head.val);
                a.next = ans1;
                a = a.next;
                head = head.next;
            }
            else{
                ListNode ans2 = new ListNode(head.val);
                b.next = ans2;
                b = b.next;
                head = head.next;
            }
            i++;
        }
        a.next = cur2.next;
        return cur1.next;

    }
    
    
}
```


## 力扣23 合并K个升序链表
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210120224637120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
朴素法：
	遍历链表数组，每次将两个链表合并排序，返回新的链表
	合并两个有序链表参考剑指offer25
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode ans = null;
        for (int i = 0; i < lists.length; ++i) {
            ans = mergeTwoLists(ans, lists[i]);
        }
        return ans;

    }
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        int len1 = getLength(l1);
        int len2 = getLength(l2);
        if(len1 == 0){
            return l2;
        }
        if(len2 == 0){
            return l1;
        }
        int[] arr = new int[len1+len2];
        for(int i=0; i<len1; i++){
            arr[i] = l1.val;
            l1 = l1.next;
        }
        for(int i=len1; i<len1+len2; i++){
            arr[i] = l2.val;
            l2 = l2.next;
        }
        Arrays.sort(arr);
        ListNode head = new ListNode(arr[0]);
        ListNode cur = head;
        for(int i=1; i<len1+len2; i++){
            ListNode ans = new ListNode(arr[i]);
            head.next = ans;
            head = head.next;            
        }
        return cur;
    }
    public int getLength(ListNode head){
        int len = 0;
        while(head!=null){
            len++;
            head = head.next;
        }
        return len;
    }
}
```

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode ans = null;
        for (int i = 0; i < lists.length; ++i) {
            ans = mergeTwoLists(ans, lists[i]);
        }
        return ans;
    }

    public ListNode mergeTwoLists(ListNode a, ListNode b) {
        if (a == null || b == null) {
            return a != null ? a : b;
        }
        ListNode head = new ListNode(0);
        ListNode tail = head, aPtr = a, bPtr = b;
        while (aPtr != null && bPtr != null) {
            if (aPtr.val < bPtr.val) {
                tail.next = aPtr;
                aPtr = aPtr.next;
            } else {
                tail.next = bPtr;
                bPtr = bPtr.next;
            }
            tail = tail.next;
        }
        tail.next = (aPtr != null ? aPtr : bPtr);
        return head.next;
    }
}
```

## 力扣628 三个数的最大乘积

方法一：排序
首先将数组排序。

如果数组中全是非负数，则排序后最大的三个数相乘即为最大乘积；如果全是非正数，则最大的三个数相乘同样也为最大乘积。

如果数组中有正数有负数，则最大乘积既可能是三个最大正数的乘积，也可能是两个最小负数（即绝对值最大）与最大正数的乘积。

综上，我们在给数组排序后，分别求出三个最大正数的乘积，以及两个最小负数与最大正数的乘积，二者之间的最大值即为所求答案。

```java
最小的两个和最大值：处理最小值为负数时
max（最大的三个的积，最小的两个数和最大值的积）  
class Solution {
    public int maximumProduct(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        return Math.max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1]);
    }
}
```

复杂度分析

时间复杂度：O(N\log N)O(NlogN)，其中 NN 为数组长度。排序需要 O(N\log N)O(NlogN) 的时间。

空间复杂度：O(\log N)O(logN)，主要为排序的空间开销。

方法二：线性扫描
在方法一中，我们实际上只要求出数组中最大的三个数以及最小的两个数，因此我们可以不用排序，用线性扫描直接得出这五个数。

```java
class Solution {
    public int maximumProduct(int[] nums) {
        // 最小的和第二小的
        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
        // 最大的、第二大的和第三大的
        int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;

        for (int x : nums) {
            if (x < min1) {
                min2 = min1;
                min1 = x;
            } else if (x < min2) {
                min2 = x;
            }

            if (x > max1) {
                max3 = max2;
                max2 = max1;
                max1 = x;
            } else if (x > max2) {
                max3 = max2;
                max2 = x;
            } else if (x > max3) {
                max3 = x;
            }
        }

        return Math.max(min1 * min2 * max1, max1 * max2 * max3);
    }
}
```
## 力扣122 买卖股票的最佳时机
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210120143543138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210120143208224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)


```java
class Solution {
    public int maxProfit(int[] prices) {
        int profit = 0;
        for (int i = 1; i < prices.length; i++) {
            int tmp = prices[i] - prices[i - 1];
            if (tmp > 0) profit += tmp;
        }
        return profit;
    }
}


```
## 力扣876 链表的中间节点
法一：遍历一次记录链表长度   除以二取中间找到该节点
```java
方法三：快慢指针法
思路和算法

我们可以继续优化方法二，用两个指针 slow 与 fast 一起遍历链表。slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。

C++JavaPythonJavaScript

class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
};

```

## 面试题 02.07 链表相交
给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。


示例 1：

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

示例 2：

输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

示例 3：

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210120152501911.png)


```java
注意：当没有交点时，二者会同时指向null，因此也满足t1==t2的条件，终止循环
当有交点时，会在交点处终止循环
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode t1 = headA;
        ListNode t2 = headB;
        while(t1 != t2){
            t1 = t1 != null ? t1.next : headB;
            t2 = t2 != null ? t2.next : headA;
        }
        return t2;
    }
}
```

## 203、移除链表元素

删除链表中等于给定值 val 的所有节点。

示例:

输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5


```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode sentinel = new ListNode(0);
        sentinel.next = head;

        ListNode prev = sentinel, curr = head;
        while (curr != null) {
            if (curr.val == val) prev.next = curr.next;
            else prev = curr;
            curr = curr.next;
        }
        return sentinel.next;
    }
}

```

## 力扣19删除链表的倒数第n个节点

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.


```java
思路:链表题涉及到位置索引的可以通过设计方法来求链表长度
注意，初始化一个纸箱head的节点列表：ListNode dummy = new ListNode(0,head);
首先现找到倒数第n-1个节点
	寻找方法，通过for(int i = 1;i<len-n+1;i++){
            cur = cur.next;
        }
    cur.next = cur.next.next;
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0,head);
        int len = getlength(head);
        ListNode cur = dummy;
        for(int i = 1;i<len-n+1;i++){
            cur = cur.next;
        }
        cur.next = cur.next.next;
        return dummy.next;
    }
    public int getlength(ListNode head){
        int len = 0;
        while(head!=null){
            len++;
            head = head.next;
        }
        return len;
    }
}
```

## 力扣225用队列实现栈

队列的基本操作
add和offer都是增加元素  ，add在超出范围时会报错
offer不会理解报错
poll获取并移除队列的头
element获取队列的头  若为空则抛出异常
peek也是获取队列的头，若为空曾返回null
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021011813110063.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210118131103517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210118131219337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
使用队列实现栈的下列操作：

push(x) -- 元素 x 入栈
pop() -- 移除栈顶元素
top() -- 获取栈顶元素
empty() -- 返回栈是否为空
注意:

你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。
你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

解答：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210118135817588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
**在队列中   每送入第n个元素，要将队列的前n-1移出并按送入顺序依次移入序列中，如上图**
```java
思路：
首先明确队列先进先出的方式  

push: 将队列中总入新元素之后，还要将队列的头元素poll再offer送入队列queue.offer(queue.poll());  重复queue.size次
pop:每次送出队列的头部元素  queue.poll()
top:queue.peek()操作
empty:queue.isEmpty()
方法二：一个队列
方法一使用了两个队列实现栈的操作，也可以使用一个队列实现栈的操作。

使用一个队列时，为了满足栈的特性，即最后入栈的元素最先出栈，同样需要满足队列前端的元素是最后入栈的元素。

入栈操作时，首先获得入栈前的元素个数 nn，然后将元素入队到队列，再将队列中的前 nn 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。

由于每次入栈操作都确保队列的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除队列的前端元素并返回即可，获得栈顶元素操作只需要获得队列的前端元素并返回即可（不移除元素）。

由于队列用于存储栈内的元素，判断栈是否为空时，只需要判断队列是否为空即可。


class MyStack {
    Queue<Integer> queue;
    /** Initialize your data structure here. */
    public MyStack() {
        queue = new LinkedList<Integer>();
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        int n = queue.size();
        queue.offer(x);
        for(int i=0;i<n;i++){
            queue.offer(queue.poll());
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        return queue.poll();
    }
    
    /** Get the top element. */
    public int top() {
        return queue.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return queue.isEmpty();
    }
```


## 面试题10.01 合并排序的数组
从A[m]开始依次存入B[0]直到B[n]
再排序


给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。

初始化 A 和 B 的元素数量分别为 m 和 n。

示例:

输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
说明:

```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
        for (int i = 0; i != n; ++i) {
            A[m + i] = B[i];
        }
        Arrays.sort(A);
    }
}
```

## 力扣34在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：

你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？


示例 1：

输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
示例 2：

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
示例 3：

输入：nums = [], target = 0
输出：[-1,-1]

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] arr = new int[2];
        arr[0]=-1;
        arr[1]=-1;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==target){
                arr[0]=i;
                break;
            }
        }
        if(arr[0]==-1){
            return arr;
        }
        arr[1]=arr[0];
        for(int i = arr[0]+1;i<nums.length;i++){
            if(nums[i]==target){
                arr[1]=i;
            }
            else{
                break;
            }
        }
        return arr;
    }
}
```

## 力扣8字符串转换整数：

请你来实现一个 atoi 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：

如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。
假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0 。

注意：

本题中的空白字符只包括空格字符 ' ' 。
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  231 − 1 或 −231 。



🙋🙋我来了~~ 最近这几天非常忙，leetcode和公众号的消息不能及时回复见谅！我会抽空一条条回复的！现在先来打卡啦~

这道题目其实出得有点恶心，需要比较仔细才可以通过。当然比这题更恶心的是要需要识别科学计数法，识别二进制(0b01)，八进制（012)，十六进制（0xab），不知道leetcode会不会丧心病狂出这样的题目（或者已经有了？）。。

这题的做法大概是这样：

去掉前导空格
再是处理正负号
识别数字，注意越界情况。
这道题目如果只是简单地字符串转整数的话，就是简单地 ans = ans * 10 + digit。
但是注意这道题目可能会超过integer的最大表示！
也就是说会在某一步 ans * 10 + digit > Integer.MAX_VALUE。
*10 和 +digit 都有可能越界，那么只要把这些都移到右边去就可以了。
ans > (Integer.MAX_VALUE - digit) / 10 就是越界。

不过我的忠告是，等真正工作以后，尽可能地调用jdk的方法，比如Character.isDigit。如果没有你想要的api，也要尽量使用guava，apache common等常见的utils包，尽量不要自己造轮子，一是这样减少出错的可能，二是比较无脑，保护脑细胞~

下面是代码：


```java
public class Solution {
    public int myAtoi(String str) {
        char[] chars = str.toCharArray();
        int n = chars.length;
        int idx = 0;
        while (idx < n && chars[idx] == ' ') {
            // 去掉前导空格
            idx++;
        }
        if (idx == n) {
            //去掉前导空格以后到了末尾了
            return 0;
        }
        boolean negative = false;
        if (chars[idx] == '-') {
            //遇到负号
            negative = true;
            idx++;
        } else if (chars[idx] == '+') {
            // 遇到正号
            idx++;
        } else if (!Character.isDigit(chars[idx])) {
            // 其他符号
            return 0;
        }
        int ans = 0;
        while (idx < n && Character.isDigit(chars[idx])) {
            int digit = chars[idx] - '0';
            if (ans > (Integer.MAX_VALUE - digit) / 10) {
                // 本来应该是 ans * 10 + digit > Integer.MAX_VALUE
                // 但是 *10 和 + digit 都有可能越界，所有都移动到右边去就可以了。
                return negative? Integer.MIN_VALUE : Integer.MAX_VALUE;
            }
            ans = ans * 10 + digit;
            idx++;
        }
        return negative? -ans : ans;
    }
}
```

## 力扣15：三数之和
思路
标签：数组遍历
首先对数组进行排序，排序后固定一个数 nums[i]nums[i]，再使用左右指针指向 nums[i]nums[i]后面的两端，数字分别为 nums[L]nums[L] 和 nums[R]nums[R]，计算三个数的和 sumsum 判断是否满足为 00，满足则添加进结果集
如果 nums[i]nums[i]大于 00，则三数之和必然无法等于 00，结束循环
如果 nums[i]nums[i] == nums[i-1]nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过
当 sumsum == 00 时，nums[L]nums[L] == nums[L+1]nums[L+1] 则会导致结果重复，应该跳过，L++L++
当 sumsum == 00 时，nums[R]nums[R] == nums[R-1]nums[R−1] 则会导致结果重复，应该跳过，R--R−−
时间复杂度：O(n^2)O(n 
2
 )，nn 为数组长度
代码

```java

class Solution {
    public static List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList();
        int len = nums.length;
        if(nums == null || len < 3) return ans;
        Arrays.sort(nums); // 排序
        for (int i = 0; i < len ; i++) {
            if(nums[i] > 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环
            if(i > 0 && nums[i] == nums[i-1]) continue; // 去重
            int L = i+1;
            int R = len-1;
            while(L < R){
                int sum = nums[i] + nums[L] + nums[R];
                if(sum == 0){
                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));
                    while (L<R && nums[L] == nums[L+1]) L++; // 去重
                    while (L<R && nums[R] == nums[R-1]) R--; // 去重
                    L++;
                    R--;
                }
                else if (sum < 0) L++;
                else if (sum > 0) R--;
            }
        }        
        return ans;
    }
}
```




![在这里插入图片描述](https://img-blog.csdnimg.cn/20210119192846592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        if(head==null){
            return head;
        }
        if(head.next==null){
            return head;
        }
        ListNode aa = new ListNode(0,head);
        aa = aa.next;
        int len = getlength(head);
        int[] arr = new int[len];
        for(int i=0;i<len;i++){
            arr[i] = aa.val;
            aa = aa.next;
        }
        for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; ++j) {
				if (arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
					//show();
				}
			}
		}
        ListNode min = new ListNode(0,head);
        ListNode a = min;
        for(int i = 0;i<len;i++){
            min.val = arr[i];
           
            if(i==len-1){
                min.next = null;
            };
            min = min.next;
        }
        return a;

    }
    public int getlength(ListNode head){
        int len = 0;
        while(head!=null){
            len++;
            head = head.next;
        }
        return len;
    }
}
```

## 力扣19删除链表的倒数第n个节点

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.


```java
思路:链表题涉及到位置索引的可以通过设计方法来求链表长度
注意，初始化一个纸箱head的节点列表：ListNode dummy = new ListNode(0,head);
首先现找到倒数第n-1个节点
	寻找方法，通过for(int i = 1;i<len-n+1;i++){
            cur = cur.next;
        }
    cur.next = cur.next.next;
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0,head);
        int len = getlength(head);
        ListNode cur = dummy;
        for(int i = 1;i<len-n+1;i++){
            cur = cur.next;
        }
        cur.next = cur.next.next;
        return dummy.next;
    }
    public int getlength(ListNode head){
        int len = 0;
        while(head!=null){
            len++;
            head = head.next;
        }
        return len;
    }
}
```

## 力扣225用队列实现栈

队列的基本操作
add和offer都是增加元素  ，add在超出范围时会报错
offer不会理解报错
poll获取并移除队列的头
element获取队列的头  若为空则抛出异常
peek也是获取队列的头，若为空曾返回null
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021011813110063.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210118131103517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210118131219337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
使用队列实现栈的下列操作：

push(x) -- 元素 x 入栈
pop() -- 移除栈顶元素
top() -- 获取栈顶元素
empty() -- 返回栈是否为空
注意:

你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。
你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

解答：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210118135817588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)
**在队列中   每送入第n个元素，要将队列的前n-1移出并按送入顺序依次移入序列中，如上图**
```java
思路：
首先明确队列先进先出的方式  

push: 将队列中总入新元素之后，还要将队列的头元素poll再offer送入队列queue.offer(queue.poll());  重复queue.size次
pop:每次送出队列的头部元素  queue.poll()
top:queue.peek()操作
empty:queue.isEmpty()
方法二：一个队列
方法一使用了两个队列实现栈的操作，也可以使用一个队列实现栈的操作。

使用一个队列时，为了满足栈的特性，即最后入栈的元素最先出栈，同样需要满足队列前端的元素是最后入栈的元素。

入栈操作时，首先获得入栈前的元素个数 nn，然后将元素入队到队列，再将队列中的前 nn 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底。

由于每次入栈操作都确保队列的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除队列的前端元素并返回即可，获得栈顶元素操作只需要获得队列的前端元素并返回即可（不移除元素）。

由于队列用于存储栈内的元素，判断栈是否为空时，只需要判断队列是否为空即可。


class MyStack {
    Queue<Integer> queue;
    /** Initialize your data structure here. */
    public MyStack() {
        queue = new LinkedList<Integer>();
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        int n = queue.size();
        queue.offer(x);
        for(int i=0;i<n;i++){
            queue.offer(queue.poll());
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        return queue.poll();
    }
    
    /** Get the top element. */
    public int top() {
        return queue.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return queue.isEmpty();
    }
```


## 面试题10.01 合并排序的数组
从A[m]开始依次存入B[0]直到B[n]
再排序


给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。

初始化 A 和 B 的元素数量分别为 m 和 n。

示例:

输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
说明:

```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
        for (int i = 0; i != n; ++i) {
            A[m + i] = B[i];
        }
        Arrays.sort(A);
    }
}
```

## 力扣34在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：

你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？


示例 1：

输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
示例 2：

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
示例 3：

输入：nums = [], target = 0
输出：[-1,-1]

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] arr = new int[2];
        arr[0]=-1;
        arr[1]=-1;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==target){
                arr[0]=i;
                break;
            }
        }
        if(arr[0]==-1){
            return arr;
        }
        arr[1]=arr[0];
        for(int i = arr[0]+1;i<nums.length;i++){
            if(nums[i]==target){
                arr[1]=i;
            }
            else{
                break;
            }
        }
        return arr;
    }
}
```

## 力扣8字符串转换整数：

请你来实现一个 atoi 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：

如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。
假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0 。

注意：

本题中的空白字符只包括空格字符 ' ' 。
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  231 − 1 或 −231 。



🙋🙋我来了~~ 最近这几天非常忙，leetcode和公众号的消息不能及时回复见谅！我会抽空一条条回复的！现在先来打卡啦~

这道题目其实出得有点恶心，需要比较仔细才可以通过。当然比这题更恶心的是要需要识别科学计数法，识别二进制(0b01)，八进制（012)，十六进制（0xab），不知道leetcode会不会丧心病狂出这样的题目（或者已经有了？）。。

这题的做法大概是这样：

去掉前导空格
再是处理正负号
识别数字，注意越界情况。
这道题目如果只是简单地字符串转整数的话，就是简单地 ans = ans * 10 + digit。
但是注意这道题目可能会超过integer的最大表示！
也就是说会在某一步 ans * 10 + digit > Integer.MAX_VALUE。
*10 和 +digit 都有可能越界，那么只要把这些都移到右边去就可以了。
ans > (Integer.MAX_VALUE - digit) / 10 就是越界。

不过我的忠告是，等真正工作以后，尽可能地调用jdk的方法，比如Character.isDigit。如果没有你想要的api，也要尽量使用guava，apache common等常见的utils包，尽量不要自己造轮子，一是这样减少出错的可能，二是比较无脑，保护脑细胞~

下面是代码：


```java
public class Solution {
    public int myAtoi(String str) {
        char[] chars = str.toCharArray();
        int n = chars.length;
        int idx = 0;
        while (idx < n && chars[idx] == ' ') {
            // 去掉前导空格
            idx++;
        }
        if (idx == n) {
            //去掉前导空格以后到了末尾了
            return 0;
        }
        boolean negative = false;
        if (chars[idx] == '-') {
            //遇到负号
            negative = true;
            idx++;
        } else if (chars[idx] == '+') {
            // 遇到正号
            idx++;
        } else if (!Character.isDigit(chars[idx])) {
            // 其他符号
            return 0;
        }
        int ans = 0;
        while (idx < n && Character.isDigit(chars[idx])) {
            int digit = chars[idx] - '0';
            if (ans > (Integer.MAX_VALUE - digit) / 10) {
                // 本来应该是 ans * 10 + digit > Integer.MAX_VALUE
                // 但是 *10 和 + digit 都有可能越界，所有都移动到右边去就可以了。
                return negative? Integer.MIN_VALUE : Integer.MAX_VALUE;
            }
            ans = ans * 10 + digit;
            idx++;
        }
        return negative? -ans : ans;
    }
}
```

## 力扣15：三数之和
思路
标签：数组遍历
首先对数组进行排序，排序后固定一个数 nums[i]nums[i]，再使用左右指针指向 nums[i]nums[i]后面的两端，数字分别为 nums[L]nums[L] 和 nums[R]nums[R]，计算三个数的和 sumsum 判断是否满足为 00，满足则添加进结果集
如果 nums[i]nums[i]大于 00，则三数之和必然无法等于 00，结束循环
如果 nums[i]nums[i] == nums[i-1]nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过
当 sumsum == 00 时，nums[L]nums[L] == nums[L+1]nums[L+1] 则会导致结果重复，应该跳过，L++L++
当 sumsum == 00 时，nums[R]nums[R] == nums[R-1]nums[R−1] 则会导致结果重复，应该跳过，R--R−−
时间复杂度：O(n^2)O(n 
2
 )，nn 为数组长度
代码

```java

class Solution {
    public static List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList();
        int len = nums.length;
        if(nums == null || len < 3) return ans;
        Arrays.sort(nums); // 排序
        for (int i = 0; i < len ; i++) {
            if(nums[i] > 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环
            if(i > 0 && nums[i] == nums[i-1]) continue; // 去重
            int L = i+1;
            int R = len-1;
            while(L < R){
                int sum = nums[i] + nums[L] + nums[R];
                if(sum == 0){
                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));
                    while (L<R && nums[L] == nums[L+1]) L++; // 去重
                    while (L<R && nums[R] == nums[R-1]) R--; // 去重
                    L++;
                    R--;
                }
                else if (sum < 0) L++;
                else if (sum > 0) R--;
            }
        }        
        return ans;
    }
}
```




![在这里插入图片描述](https://img-blog.csdnimg.cn/20210119192846592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        if(head==null){
            return head;
        }
        if(head.next==null){
            return head;
        }
        ListNode aa = new ListNode(0,head);
        aa = aa.next;
        int len = getlength(head);
        int[] arr = new int[len];
        for(int i=0;i<len;i++){
            arr[i] = aa.val;
            aa = aa.next;
        }
        for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length - i - 1; ++j) {
				if (arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
					//show();
				}
			}
		}
        ListNode min = new ListNode(0,head);
        ListNode a = min;
        for(int i = 0;i<len;i++){
            min.val = arr[i];
           
            if(i==len-1){
                min.next = null;
            };
            min = min.next;
        }
        return a;

    }
    public int getlength(ListNode head){
        int len = 0;
        while(head!=null){
            len++;
            head = head.next;
        }
        return len;
    }
}
```

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<script>
			/*
				1. 事件: 点击事件 onclick
				2. 事件要触发函数: changeImg
				3. 在函数中
			*/
			function changeImg(){
//				alert("要切换了")
				var img = document.getElementById("img1");//获取图片名称
				img.src = "../img/1-161104143944.gif";
			}
		</script>
	</head>
	<body>
		<input type="button" value="点击切换图片" onclick="changeImg()" />
		<br />
		<img src="../img/2.jpg" id="img1" />
	</body>
</html>
```

## 力扣111 二叉树的最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

 

示例 1：


输入：root = [3,9,20,null,null,15,7]
输出：2
示例 2：

输入：root = [2,null,3,null,4,null,5,null,6]
输出：5

```java
思路  相同节点的左右节点一个为空 那么该节点深度的最小值 就是为空的那个叶子节点，因为不为空的一定大于为空的深度。
	  注释：对应这段代码if (root.left == null && root.right == null) {
		            return 1;
		        }
      当两个节点都不为空时，就继续分别寻找左右节点的值 
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        if (root.left == null && root.right == null) {
            return 1;
        }

        int min_depth = Integer.MAX_VALUE;
        if (root.left != null) {
            min_depth = Math.min(minDepth(root.left), min_depth);
        }
        if (root.right != null) {
            min_depth = Math.min(minDepth(root.right), min_depth);
        }

        return min_depth + 1;
    }
}
```


输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

 

示例：

给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.

## 剑指offer22 链表中的倒数第K个节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode cur = new ListNode(0,head);
        int len = getsize(head);
        for(int i = 0;i<len-k;i++){
            head = head.next;
        }
        cur.next = head;
        return cur.next;
    }
    public int getsize(ListNode head){
        int a = 0;
        while(head!=null){
            head = head.next;
            a++;
        }
        return a;
    }
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210119150439186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzEwNzEw,size_16,color_FFFFFF,t_70)

```java
思路  前面指针和后面指针差距为k  前一个指针到达终点  则后一个指针刚好为要找的倒数第k个节点
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode former = head, latter = head;
        for(int i = 0; i < k; i++)
            former = former.next;
        while(former != null) {
            former = former.next;
            latter = latter.next;
        }
        return latter;
    }
}


```


## 剑指offer03.找出数组中重复的数字。

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 

```java
思路：利用哈希表不能添加重复元素的原理，当送入相同元素时，返回null   因此当送入重复元素时，立即break或者返回
class Solution {
    public int findRepeatNumber(int[] nums) {
        Set<Integer> set = new HashSet<Integer>();
        int repeat = -1;
        for (int num : nums) {
            if (!set.add(num)) {
                repeat = num;
                break;
            }
        }
        return repeat;
    }
}

```