下面关于B-和B+树的叙述中，不正确的是

1、B-树和B+树都是平衡的多叉树
2、B-树和B+树都可用于文件的索引结构
**3、B-树和B+树都能有效地支持顺序检索**
4、B-树和B+树都能有效地支持随机检索

```

```

**B- 树**

​    是一种多路搜索树（并不是二叉的）：

​    \1. 定义任意非叶子结点最多只有 M 个儿子；且 M>2 ；

​    \2. 根结点的儿子数为 [2, M] ；

​    \3. 除根结点以外的非叶子结点的儿子数为 [M/2, M] ；

​    \4. 每个结点存放至少 M/2-1 （取上整）和至多 M-1 个关键字；（至少 2 个关键字）

​    \5. 非叶子结点的关键字个数 = 指向儿子的指针个数 -1 ；

​    \6. 非叶子结点的关键字： K[1], K[2], …, K[M-1] ；且 K[i] < K[i+1] ；

​    \7. 非叶子结点的指针： P[1], P[2], …, P[M] ；其中 P[1] 指向关键字小于 K[1] 的子树， P[M] 指向关键字大于 K[M-1] 的子树，其它 P[i] 指向关键字属于 (K[i-1], K[i]) 的子树；

​    \8. 所有叶子结点位于同一层；

![image](http://images.cnblogs.com/cnblogs_com/syxchina/201110/201110012318587145.png)

 B- 树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；

B- 树的特性：

​    \1. 关键字集合分布在整颗树中；

​    \2. 任何一个关键字出现且只出现在一个结点中；

​    \3. 搜索有可能在非叶子结点结束；

​    \4. 其搜索性能等价于在关键字全集内做一次二分查找；

​    \5. 自动层次控制；

​    由于限制了除根结点以外的非叶子结点，至少含有 M/2 个儿子，确保了结点的至少利用率，其最底搜索性能为：

![image](http://images.cnblogs.com/cnblogs_com/syxchina/201110/201110012318589936.png)

其中， M 为设定的非叶子结点最多子树个数， N 为关键字总数；

​    所以 B- 树的性能总是等价于二分查找（与 M 值无关），也就没有 B 树平衡的问题；

​    由于 M/2 的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占 M/2 的结点；删除结点时，需将两个不足 M/2 的兄弟结点合并；

**B+ 树**

​    B+ 树是 B- 树的变体，也是一种多路搜索树：

​    \1. 其定义基本与 B- 树同，除了：

​    \2. 非叶子结点的子树指针与关键字个数相同；

​    \3. 非叶子结点的子树指针 P[i] ，指向关键字值属于 [K[i], K[i+1]) 的子树（ B- 树是开区间）；

​    \5. 为所有叶子结点增加一个链指针；

​    \6. 所有关键字都在叶子结点出现；

​    如：（ M=3 ）

![image](http://images.cnblogs.com/cnblogs_com/syxchina/201110/20111001231859983.png)

 B+ 的搜索与 B- 树也基本相同，区别是 B+ 树只有达到叶子结点才命中（ B- 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

​    B+ 的特性：

​    \1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；

​    \2. 不可能在非叶子结点命中；

​    \3. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；

​    \4. 更适合文件索引系统；

  

**B\* 树**

​    是 B+ 树的变体，在 B+ 树的非根和非叶子结点再增加指向兄弟的指针；

![image](http://images.cnblogs.com/cnblogs_com/syxchina/201110/201110012319014688.png)

B* 树定义了非叶子结点关键字个数至少为 (2/3)*M ，即块的最低使用率为 2/3 （代替 B+ 树的 1/2 ）；

​    B+ 树的分裂：当一个结点满时，分配一个新的结点，并将原结点中 1/2 的数据复制到新结点，最后在父结点中增加新结点的指针； B+ 树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；

​    B* 树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制 1/3 的数据到新结点，最后在父结点增加新结点的指针；

​    所以， B* 树分配新结点的概率比 B+ 树要低，空间使用率更高；



各种排序应用场景：

插入排序：如果平均每个元素离最终位置相距c个元素，则其复杂度为O(cn)，一共n趟，每次比较c次；

快速排序：最好的、平均的复杂度都是O(nlog(n))，如果每次选择的中间数都最小或最大，那就是最坏的情况，复杂度是O(n*n)；所以快速排序和元素的位置没有关系，跟选择的中间数有关。

堆排序：复杂度一直是O(nlog(n));

直接选择排序：跟元素位置没有关系，都要遍历n遍，每遍找出最小或最大数来，复杂度是O(n*n)；

答案是插入排序。





逆波兰表达式



哈夫曼树

![img](https://uploadfiles.nowcoder.com/images/20161031/6306378_1477892872536_FB5C81ED3A220004B71069645F112867)



具有n个节点的完全二叉树的深度为log2(n)向下取整+！